<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.2" />
<title>ADRpy.atmospheres API documentation</title>
<meta name="description" content="atmospheres.py:
Definitions of atmosphere models for use in aircraft engineering: â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>ADRpy.atmospheres</code> module</h1>
</header>
<section id="section-intro">
<p>atmospheres.py:
Definitions of atmosphere models for use in aircraft engineering:</p>
<ul>
<li>
<p>The International Standard Atmosphere model. Based on ESDU
Data Item 77022, "Equations for calculation of International
Standard Atmosphere and associated off-standard atmospheres",
published 1977, amended 2008. It covers the first
50km of
the atmosphere</p>
</li>
<li>
<p>Off-standard, temperature offset version of the above</p>
</li>
<li>
<p>Extremely warm/cold, and low/high density atmospheres from US
MIL HDBK 310</p>
</li>
<li>
<p>User-defined atmospheres based on interpolated data</p>
</li>
</ul>
<p>Contains the following class definitions:
<a title="ADRpy.atmospheres.Runway" href="#ADRpy.atmospheres.Runway"><code>Runway</code></a>
<a title="ADRpy.atmospheres.Obsprofile" href="#ADRpy.atmospheres.Obsprofile"><code>Obsprofile</code></a>
<a title="ADRpy.atmospheres.Atmosphere" href="#ADRpy.atmospheres.Atmosphere"><code>Atmosphere</code></a></p>
<p>Unit tests in t_atmospheres.py. Checking against data from the 1976
US Standard Atmosphere, NASA-TM-X-74335. ESDU 77022 describes its
ISA model as being identical for all practical purposes with the US
Standard Atmospheres.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;atmospheres.py:
Definitions of atmosphere models for use in aircraft engineering:

 - The International Standard Atmosphere model. Based on ESDU
Data Item 77022, &#34;Equations for calculation of International
Standard Atmosphere and associated off-standard atmospheres&#34;,
published 1977, amended 2008. It covers the first  50km of
the atmosphere

 - Off-standard, temperature offset version of the above

 - Extremely warm/cold, and low/high density atmospheres from US
MIL HDBK 310

 - User-defined atmospheres based on interpolated data

Contains the following class definitions:
    `Runway`
    `Obsprofile`
    `Atmosphere`

Unit tests in t_atmospheres.py. Checking against data from the 1976
US Standard Atmosphere, NASA-TM-X-74335. ESDU 77022 describes its
ISA model as being identical for all practical purposes with the US
Standard Atmospheres.
&#34;&#34;&#34;
__author__ = &#34;Andras Sobester&#34;


import math
from numbers import Number
import csv
import os
import numpy as np
from scipy import interpolate
from ADRpy import unitconversions as co
from ADRpy import mtools4acdc as mtools

# pylint: disable=locally-disabled, too-many-instance-attributes, too-few-public-methods
# pylint: disable=locally-disabled, too-many-arguments, too-many-statements
# pylint: disable-msg=R0914

# Specific gas constant for dry air
# (in Joules ) per kilogram per Kelvin
R_JPKGPK = 287.05287
# Radius of Earth at 45deg latitude, adopted in ISA for
# the calculation of geopotential height
R_EARTH_M = 6356766
# Dry air ratio of specific heats
GAMMA_DRY_AIR = 1.401

def idealgasdens_kgm3(p_pa, temp_k):
    &#34;&#34;&#34;Density from pressure and temperature, on ideal gas assumption&#34;&#34;&#34;
    return p_pa / R_JPKGPK / temp_k

def idealgaspress_pa(rho_kgpm3, temp_k):
    &#34;&#34;&#34;Pressure from density and temperature, on ideal gas assumption&#34;&#34;&#34;
    return R_JPKGPK * rho_kgpm3 * temp_k

def geom2geop45m(altitude_m):
    &#34;&#34;&#34;Convert geometric height to geopotential (m) assuming 45deg lat&#34;&#34;&#34;
    return R_EARTH_M * altitude_m / (R_EARTH_M + altitude_m)

def geop2geom45m(altitude_m):
    &#34;&#34;&#34;Convert geometric height to geopotential (m) assuming 45deg lat&#34;&#34;&#34;
    return R_EARTH_M * altitude_m / (R_EARTH_M - altitude_m)

class Runway:
    &#34;&#34;&#34;Parameters and methods of runway definition&#34;&#34;&#34;

    def __init__(self, icao_code=None, rwyno=0,
                 elevation_ft=0, heading=0, surf=&#39;ASP&#39;,
                 length_ft=10000, width_ft=100):
        if icao_code:
            # Read relevant runway data from the ourairports.com database
            # le_... / he_... - numbers referring to the low/high end respectively
            rwy_file = os.path.join(os.path.dirname(__file__), &#34;data&#34;, &#34;runways.csv&#34;)
            with open(rwy_file, newline=&#39;&#39;) as rwyfile:
                runwaydata = csv.reader(rwyfile, delimiter=&#39;,&#39;)
                runwaylist = []
                for row in runwaydata:
                    runwaylist.append(row)
            rindlst = [i for i, rwy in enumerate(runwaylist) if rwy[2] == icao_code]
            rind = rindlst[0]
            self.ident = runwaylist[rind + rwyno][0]
            self.airport_ref = runwaylist[rind + rwyno][1]
            self.airport_ident = runwaylist[rind + rwyno][2]
            self.length_ft = float(runwaylist[rind + rwyno][3])
            self.width_ft = float(runwaylist[rind + rwyno][4])
            self.surface = runwaylist[rind + rwyno][5]
            self.lighted = runwaylist[rind + rwyno][6]
            self.closed = runwaylist[rind + rwyno][7]
            self.le_ident = runwaylist[rind + rwyno][8]
            self.le_latitude_deg = runwaylist[rind + rwyno][9]
            self.le_longitude_deg = runwaylist[rind + rwyno][10]
            self.le_elevation_ft = float(runwaylist[rind + rwyno][11])
            self.le_heading_degt = float(runwaylist[rind + rwyno][12])
            try:
                self.le_displaced_threshold_ft = float(runwaylist[rind + rwyno][13])
            except ValueError:
                self.le_displaced_threshold_ft = float(&#39;nan&#39;)
            self.he_ident = runwaylist[rind + rwyno][14]
            self.he_latitude_deg = runwaylist[rind + rwyno][15]
            self.he_longitude_deg = runwaylist[rind + rwyno][16]
            self.he_elevation_ft = float(runwaylist[rind + rwyno][17])
            self.he_heading_degt = float(runwaylist[rind + rwyno][18])
            try:
                self.he_displaced_threshold_ft = float(runwaylist[rind + rwyno][19])
            except ValueError:
                self.he_displaced_threshold_ft = float(&#39;nan&#39;)
        else:
            # Define a custom runway based on the data provided
            self.ident = &#39;0000000&#39;
            self.airport_ref = &#39;0000&#39;
            self.airport_ident = &#39;CUST&#39;
            self.length_ft = length_ft
            self.width_ft = width_ft
            self.surface = surf
            self.lighted = 1
            self.closed = 0
            self.le_ident = str(int(heading/10))
            self.le_latitude_deg = 0
            self.le_longitude_deg = 0
            self.le_elevation_ft = elevation_ft
            self.le_heading_degt = str(heading)
            self.le_displaced_threshold_ft = 0
            self.he_ident = str(int(reciprocalhdg(heading)/10))
            self.he_latitude_deg = 0
            self.he_longitude_deg = 0
            self.he_elevation_ft = elevation_ft
            self.he_heading_degt = str(reciprocalhdg(heading))
            self.he_displaced_threshold_ft = 0

        # Metric versions of the imperial fields listed above
        self.length_m = co.feet2m(self.length_ft)
        self.width_m = co.feet2m(self.width_ft)
        self.le_elevation_m = co.feet2m(self.le_elevation_ft)
        self.le_displaced_threshold_m = co.feet2m(self.le_displaced_threshold_ft)
        self.he_elevation_m = co.feet2m(self.he_elevation_ft)
        self.he_displaced_threshold_m = co.feet2m(self.he_displaced_threshold_ft)


    def windcomponents(self, wind_dirs_deg, wind_speeds):
        &#34;&#34;&#34;Resolves list of wind speeds and directions into runway/cross components&#34;&#34;&#34;

        speeds = mtools.recastasnpfloatarray(wind_speeds)

        # Wind speed is considered as a positive scalar
        speeds = np.abs(speeds)

        directions_deg = mtools.recastasnpfloatarray(wind_dirs_deg)

        relative_heading_rad = np.deg2rad(directions_deg - self.le_heading_degt)

        runway_component = speeds * np.cos(relative_heading_rad) # Headwind: +
        crosswind_component = speeds * np.sin(relative_heading_rad) # Right: +

        # Scalar output to a scalar input
        if isinstance(wind_dirs_deg, Number):
            return runway_component[0], crosswind_component[0]

        return runway_component, crosswind_component



class Obsprofile:
    &#34;&#34;&#34;Observed atmosphere profile data.&#34;&#34;&#34;

    def __init__(self, alt_m=None, temp_k=None, rho_kgpm3=None, p_pa=None):

        self.alt_m = np.array(alt_m)

        self.temp_k = np.array(temp_k)
        self.rho_kgpm3 = np.array(rho_kgpm3)
        self.p_pa = np.array(p_pa)

        # Check and complete the data table and build the interp functions

        # temperature (K) and density are given against an altitude scale
        if np.size(self.alt_m) == np.size(self.temp_k) == np.size(self.rho_kgpm3):
            self.p_pa = R_JPKGPK * self.rho_kgpm3 * self.temp_k
        # temperature (K) and pressure are given against an altitude scale
        elif np.size(self.alt_m) == np.size(self.temp_k) == np.size(self.p_pa):
            self.rho_kgpm3 = idealgasdens_kgm3(self.p_pa, self.temp_k)
        # speed of sound
        self.vs_mps = \
        [math.sqrt(1.4 * R_JPKGPK * T) for T in self.temp_k]

        # all data points ready, the interpolators can now be constructed
        self.ftemp_k = interpolate.interp1d(self.alt_m, self.temp_k)
        self.fp_pa = interpolate.interp1d(self.alt_m, self.p_pa)
        self.frho_kgpm3 = interpolate.interp1d(self.alt_m, self.rho_kgpm3)
        self.fvs_mps = interpolate.interp1d(self.alt_m, self.vs_mps)

    def loalt(self):
        &#34;&#34;&#34;The minimum valid altitude (in m) of the interpolators.&#34;&#34;&#34;
        return min(self.alt_m)

    def hialt(self):
        &#34;&#34;&#34;The maximum valid altitude (in m) of the interpolators.&#34;&#34;&#34;
        return max(self.alt_m)


class Atmosphere:
    &#34;&#34;&#34;Standard or off-standard/custom atmospheres.&#34;&#34;&#34;

    # INTERNATIONAL STANDARD ATMOSPHERE CONSTANTS
    # _Level limits in m =======================================================
    _Level1 = 11000
    _Level2 = 20000
    _Level3 = 32000
    _Level4 = 47000
    _Level5 = 50000
    # _Level limits in terms of density (kg/m3)=================================
    _dLevel1 = 0.36391700650017816
    _dLevel2 = 0.088034556579455497
    _dLevel3 = 0.013224937668421609
    _dLevel4 = 0.0014275295197313882
    _dLevel5 = 0.00097752213943149563
    # _Level limits in terms of density (kg/m3)=================================
    _pLevel1 = 22632.000999016603
    _pLevel2 = 5474.8699475808515
    _pLevel3 = 868.01381950678511
    _pLevel4 = 110.90599734942646
    # ISA constants, base temperatures A in K, lapse rates B in deg/m
    # Based on Table 11.3, defined in terms of &#39;pressure height Hp&#39;, SI Units
    # Layer 1 ------------------------------------------------------------------
    _A1 = 288.15
    _B1 = -6.5e-3
    _C1 = 8.9619638
    _D1 = -0.20216125e-3
    _E1 = 5.2558797
    _I1 = 1.048840
    _J1 = -23.659414e-6
    _L1 = 4.2558797
    # Layer 2 -----------------------------------------------------------------
    _A2 = 216.65
    _B2 = 0
    _F2 = 128244.5
    _G2 = -0.15768852e-3
    _M2 = 2.0621400
    _N2 = -0.15768852e-3
    # Layer 3 -----------------------------------------------------------------
    _A3 = 196.65
    _B3 = 1e-3
    _C3 = 0.70551848
    _D3 = 3.5876861e-6
    _E3 = -34.163218
    _I3 = 0.9726309
    _J3 = 4.94600e-6
    _L3 = -35.163218
    # Layer 4 -----------------------------------------------------------------
    _A4 = 139.05
    _B4 = 2.8e-3
    _C4 = 0.34926867
    _D4 = 7.0330980e-6
    _E4 = -12.201149
    _I4 = 0.84392929
    _J4 = 16.993902e-6
    _L4 = -13.201149
    # Layer 5 -----------------------------------------------------------------
    _A5 = 270.65
    _B5 = 0
    _F5 = 41828.42
    _G5 = -0.12622656e-3
    _M5 = 0.53839563
    _N5 = -0.12622656e-3
    #==========================================================================



    def __init__(self, offset_deg=0, profile=None):

        self.offset_deg = offset_deg # Relative temperature (C or K)
        self.profile = profile

        # If an altitude vector is not specified...
        if not profile is None:
            self.is_isa = False # Interpolated atmosphere
        else:
            #...then we are building an ISA
            self.is_isa = True



    def _alttest(self, reqalt_m):

        if isinstance(reqalt_m, Number):
            reqalt_m = [reqalt_m]
        # Convert to Numpy array if list
        reqalt_m = np.array(reqalt_m)
        # Recast as float, as there is no sensible reason for integers
        reqalt_m = [x.astype(float) for x in reqalt_m]

        if self.is_isa:
            if any(x &gt; self._Level5 for x in reqalt_m):
                print(&#39;Altitudes had to be limited to 50km where higher.&#39;)
                reqalt_m[reqalt_m &gt; self._Level5] = self._Level5
        else:
            minalt_m = np.amin(self.profile.alt_m)
            maxalt_m = np.amax(self.profile.alt_m)
            if any(reqalt_m &lt; minalt_m):
                print(&#39;Requested altitude below interpolation range.&#39;)
                reqalt_m[reqalt_m &lt; minalt_m] = minalt_m
            if any(reqalt_m &gt; maxalt_m):
                print(&#39;Requested altitude above interpolation range.&#39;)
                reqalt_m[reqalt_m &gt; maxalt_m] = maxalt_m

        return reqalt_m


    def _isatemp_k(self, altitude_m):
        &#34;&#34;&#34;ISA temperature as a function of geopotential altitude&#34;&#34;&#34;
        alt_it = np.nditer([altitude_m, None])
        for alt, t_k in alt_it:
            if alt &lt; self._Level1:
                # Troposphere, temperature decreases linearly
                t_k[...] = self._A1 + self._B1 * alt
            elif alt &lt; self._Level2:
                # Lower stratopshere, temperature is constant
                t_k[...] = self._A2 + self._B2 * alt
            elif alt &lt; self._Level3:
                # Upper stratopshere, temperature is increasing
                t_k[...] = self._A3 + self._B3 * alt
            elif alt &lt; self._Level4:
                # Between 32 and 47 km
                t_k[...] = self._A4 + self._B4 * alt
            else:
                # Between 47km and 51km
                t_k[...] = self._A5 + self._B5 * alt
            # Adjust for the temperature offset
            t_k[...] = t_k[...] + self.offset_deg
        return alt_it.operands[1]


    def _isapress_pa(self, altitude_m):
        &#34;&#34;&#34;ISA pressure as a function of geopotential altitude&#34;&#34;&#34;
        alt_it = np.nditer([altitude_m, None])
        for alt, pressure_pa in alt_it:
            if alt &lt; self._Level1:
                # Troposphere
                pressure_pa[...] = (self._C1 + self._D1 * alt) ** self._E1
            elif alt &lt; self._Level2:
                # Lower stratopshere
                pressure_pa[...] = self._F2 * math.exp(self._G2 * alt)
            elif alt &lt; self._Level3:
                # Upper stratopshere
                pressure_pa[...] = (self._C3 + self._D3 * alt) ** self._E3
            elif alt &lt; self._Level4:
                # Between 32 and 47 km
                pressure_pa[...] = (self._C4 + self._D4 * alt) ** self._E4
            else:
                # Between 47km and 51km
                pressure_pa[...] = self._F5 * math.exp(self._G5 * alt)
        return alt_it.operands[1]


    def _isapressalt_m(self, pressure_pa):
        &#34;&#34;&#34;Returns the geopotential alt (m) at which ISA has the given pressure&#34;&#34;&#34;
        press_it = np.nditer([pressure_pa, None])
        for press_pa, alt_m in press_it:
            if press_pa &gt; self._pLevel1:
                # Troposphere
                alt_m[...] = (press_pa ** (1 / self._E1) - self._C1) / self._D1
            elif press_pa &gt; self._pLevel2:
                # Lower stratopshere
                alt_m[...] = (1 / self._G2) * math.log1p(press_pa / self._F2 - 1)
            elif press_pa &gt; self._pLevel3:
                # Upper stratopshere
                alt_m[...] = (press_pa ** (1 / self._E3) - self._C3) / self._D3
            elif press_pa &gt; self._pLevel4:
                # Between 32 and 47 km
                alt_m[...] = (press_pa ** (1 / self._E4) - self._C4) / self._D4
            else:
                # Between 47km and 51km
                alt_m[...] = (1 / self._G5) * math.log1p(press_pa / self._F5 - 1)
        return press_it.operands[1]


    def _isadens_kgpm3(self, altitude_m):
        &#34;&#34;&#34;ISA density as a function of geopotential altitude&#34;&#34;&#34;
        alt_it = np.nditer([altitude_m, None])
        for alt, dens_kgpm3 in alt_it:
            if alt &lt; self._Level1:
                # Troposphere
                dens_kgpm3[...] = (self._I1 + self._J1 * alt) ** self._L1
            elif alt &lt; self._Level2:
                # Lower stratopshere
                dens_kgpm3[...] = self._M2 * math.exp(self._N2 * alt)
            elif alt &lt; self._Level3:
                # Upper stratopshere
                dens_kgpm3[...] = (self._I3 + self._J3 * alt) ** self._L3
            elif alt &lt; self._Level4:
                # Between 32 and 47 km
                dens_kgpm3[...] = (self._I4 + self._J4 * alt) ** self._L4
            else:
                # Between 47km and 51km
                dens_kgpm3[...] = self._M5 * math.exp(self._N5 * alt)
            # Adjust for the temperature offset
            dens_kgpm3[...] = \
            dens_kgpm3[...] / (1 + self.offset_deg / (self._isatemp_k(alt) - self.offset_deg))

        return alt_it.operands[1]


    def _isadensalt_m(self, dens_kgpm3):
        &#34;&#34;&#34;Returns the geopotential alt (m) at which ISA has given density (kg/m^3)&#34;&#34;&#34;
        dense_it = np.nditer([dens_kgpm3, None])
        for d_kgpm3, alt_m in dense_it:
            if d_kgpm3 &gt; self._dLevel1:
                # Troposphere
                alt_m[...] = (d_kgpm3 ** (1 / self._L1) - self._I1) / self._J1
            elif d_kgpm3 &gt; self._dLevel2:
                # Lower stratopshere
                alt_m[...] = (1 / self._N2) * math.log1p(dens_kgpm3 / self._M2 - 1)
            elif d_kgpm3 &gt; self._dLevel3:
                # Upper stratopshere
                alt_m[...] = (d_kgpm3 ** (1 / self._L3) - self._I3) / self._J3
            elif dens_kgpm3 &gt; self._dLevel4:
                # Between 32 and 47 km
                alt_m[...] = (d_kgpm3 ** (1 / self._L4) - self._I4) / self._J4
            else:
                # Between 47km and 51km
                alt_m[...] = (1 / self._N5) * math.log1p(d_kgpm3 / self._M5 - 1)
            # Adjust for the temperature offset
        return dense_it.operands[1]


    def airtemp_k(self, altitudes_m=0):
        &#34;&#34;&#34;Temperatures in the selected atmosphere, in K.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        if self.is_isa:
            temperatures_k = self._isatemp_k(altitudes_m)
        else:
            temperatures_k = self.profile.ftemp_k(altitudes_m)
        return _reverttoscalar(temperatures_k)


    def airpress_pa(self, altitudes_m=0):
        &#34;&#34;&#34;Pressures in the selected atmosphere, in Pa.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        if self.is_isa:
            pressures_pa = self._isapress_pa(altitudes_m)
        else:
            pressures_pa = self.profile.fp_pa(altitudes_m)
        return _reverttoscalar(pressures_pa)


    def vsound_mps(self, altitudes_m=0):
        &#34;&#34;&#34;Speed of sound in m/s at an altitude given in m.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        temperatures_k = self.airtemp_k(altitudes_m)
        vsounds_mps = _vsound_mps(temperatures_k)
        return _reverttoscalar(vsounds_mps)


    def airdens_kgpm3(self, altitudes_m=0):
        &#34;&#34;&#34;Density in kg/m^3.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        if self.is_isa:
            densities_kgpm3 = self._isadens_kgpm3(altitudes_m)
        else:
            densities_kgpm3 = self.profile.frho_kgpm3(altitudes_m)
        return _reverttoscalar(densities_kgpm3)


    def mach(self, airspeed_mps, altitude_m=0):
        &#34;&#34;&#34;Mach number at a given speed (m/s) and altitude (m)&#34;&#34;&#34;

        # Check altitude range
        altitude_m = self._alttest(altitude_m)

        # Compute speed of sound at the given altitude(s)
        vs_mps = self.vsound_mps(altitude_m)

        return airspeed_mps / vs_mps


    def vsound_kts(self, altitudes_m=0):
        &#34;&#34;&#34;Speed of sound in knots.&#34;&#34;&#34;
        return co.mps2kts(self.vsound_mps(altitudes_m))


    def airpress_mbar(self, altitudes_m=0):
        &#34;&#34;&#34;Air pressure in mbar.&#34;&#34;&#34;
        return co.pa2mbar(self.airpress_pa(altitudes_m))


    def airtemp_c(self, altitudes_m=0):
        &#34;&#34;&#34;Air temperature in Celsius.&#34;&#34;&#34;
        return co.k2c(self.airtemp_k(altitudes_m))


    def dynamicpressure_pa(self, airspeed_mps=0, altitudes_m=0):
        &#34;&#34;&#34;Dynamic pressure in the current atmosphere at a given true airspeed and altitude

        `PARAMETERS`
        ------------

        `airspeed_mps` : float, true airspeed in m/s (MPSTAS)

        `altitudes_m`: float array, altitudes in m where the dynamic pressure is to be computed


        `RETURNS`
        -----------

        float or array of floats, dynamic pressure values

        `EXAMPLE`
        -----------

        ```python
        from ADRpy import atmospheres as at
        from ADRpy import unitconversions as co

        ISA = at.Atmosphere()

        altitudelist_m = [0, 500, 1000, 1500]

        MPSTAS = 20

        q_Pa = ISA.dynamicpressure_pa(MPSTAS, altitudelist_m)

        q_mbar = co.pa2mbar(q_Pa)

        print(q_mbar)
        ```
        -----------
        ```python
        [ 2.44999974  2.33453737  2.22328473  2.11613426]
        ```
        &#34;&#34;&#34;

        return 0.5 * self.airdens_kgpm3(altitudes_m) * (airspeed_mps ** 2)


    def eas2tas(self, eas, altitude_m):
        &#34;&#34;&#34;Convert EAS to TAS at a given altitude&#34;&#34;&#34;
        dratio = self.airdens_kgpm3(altitude_m) / self.airdens_kgpm3(0)
        return eas / math.sqrt(dratio)

    def tas2eas(self, tas, altitude_m):
        &#34;&#34;&#34;Convert TAS to EAS at a given altitude&#34;&#34;&#34;
        dratio = self.airdens_kgpm3(altitude_m) / self.airdens_kgpm3(0)
        return tas * math.sqrt(dratio)

    def mpseas2mpscas(self, mpseas, altitude_m):
        &#34;&#34;&#34;Convert EAS (m/s) to CAS (m/s) at a given altitude (m)&#34;&#34;&#34;
        # Note: unit specific, as the calculation requires Mach no.
        mpstas = self.eas2tas(mpseas, altitude_m)
        machno = self.mach(mpstas, altitude_m)
        delta = self.airpress_pa(altitude_m) / self.airpress_pa()
        m2_term = (1.0 / 8.0) * (1 - delta) * (machno ** 2)
        m4_term = (3.0 / 640.0) * (1 - 10 * delta + 9 * (delta**2)) * (machno ** 4)
        return mpseas * (1 + m2_term + m4_term), machno

    def keas2kcas(self, keas, altitude_m):
        &#34;&#34;&#34;Converts equivalent airspeed into calibrated airspeed.

        `PARAMETERS`
        ------------

        `keas` : float or numpy array, equivalent airspeed in knots.

        `altitude_m` : float, altitude in metres.

        `RETURNS`
        -----------

        `kcas` : float or numpy array, calibrated airspeed in knots.

        `mach` : float, Mach number.

        `SEE ALSO`
        ------------
        ``mpseas2mpscas``

        `NOTES`
        ---------
        The reverse conversion is slightly more complicated, as their relationship
        depends on the Mach number. This, in turn, requires the computation of the
        true airspeed and that can only be computed from EAS, not CAS. The unit-
        specific nature of the function is also the result of the need for computing
        the Mach number.

        `EXAMPLE`
        ------------

        ```python
        import numpy as np
        from ADRpy import atmospheres as at
        from ADRpy import unitconversions as co

        isa = at.Atmosphere()

        keas = np.array([100, 200, 300])
        altitude_m = co.feet2m(40000)

        kcas, mach = isa.keas2kcas(keas, altitude_m)

        print(kcas)
        ```
        ---
        ```python
        [ 101.25392563  209.93839073  333.01861569]
        ```
        &#34;&#34;&#34;
        # Note: unit specific, as the calculation requires Mach no.
        np.asarray(keas)
        mpseas = co.kts2mps(keas)
        mpscas, machno = self.mpseas2mpscas(mpseas, altitude_m)
        kcas = co.mps2kts(mpscas)
        return kcas, machno


def mil_hdbk_310(high_or_low, temp_or_dens, alt_km):
    &#34;&#34;&#34;Load an atmospheric data set from US Military Handbook 310&#34;&#34;&#34;

    m310name = high_or_low + &#39;_&#39; + temp_or_dens \
    + &#39;_at_&#39; + str(alt_km) + &#39;km.m310&#39;

    _fstr = os.path.join(os.path.dirname(__file__), &#34;data&#34;,
                         &#34;_MHDBK310&#34;, m310name)

    # Also looking for m310 files in the current directory if not found
    # in a dedicated _MHDBK310 folder
    if not os.path.isfile(_fstr):
        _fstr = high_or_low + &#39;_&#39; + temp_or_dens \
        + &#39;_at_&#39; + str(alt_km) + &#39;km.m310&#39;

    try:
        if temp_or_dens == &#39;temp&#39;:
            alt_km, t_1pct_k, rho_1pct_kgpm3, t_10pct_k, rho_10pct_kgpm3 = \
            np.loadtxt(_fstr, skiprows=0, unpack=True)
        else:
            alt_km, rho_1pct_kgpm3, t_1pct_k, rho_10pct_kgpm3, t_10pct_k = \
            np.loadtxt(_fstr, skiprows=0, unpack=True)

        atm1pct = Obsprofile(alt_m=co.km2m(alt_km), temp_k=t_1pct_k, \
        rho_kgpm3=rho_1pct_kgpm3)
        atm10pct = Obsprofile(alt_m=co.km2m(alt_km), temp_k=t_10pct_k, \
        rho_kgpm3=rho_10pct_kgpm3)
        return atm1pct, atm10pct

    except FileNotFoundError:
        print(&#34;No atmosphere data file found for this combination of inputs.&#34;)
        return None, None


def _reverttoscalar(scalarorvec):
    &#34;&#34;&#34; Return scalar response to scalar input. &#34;&#34;&#34;
    if not(isinstance(scalarorvec, Number)) and np.size(scalarorvec) == 1:
        return scalarorvec[0]
    return scalarorvec


def _vsound_mps(temp_k):
    if isinstance(temp_k, Number):
        return math.sqrt(1.4 * R_JPKGPK * temp_k)
    return _reverttoscalar([math.sqrt(1.4 * R_JPKGPK * x) for x in temp_k])


def reciprocalhdg(heading_deg):
    &#34;&#34;&#34;The reciprocal of a heading in degrees&#34;&#34;&#34;
    if heading_deg + 180 &gt; 360:
        return heading_deg - 180
    return heading_deg + 180


def tempratio(temp_c, mach):
    &#34;&#34;&#34;Ratio of total temperature and the standard SL temperature&#34;&#34;&#34;
    temp_k = co.c2k(temp_c)
    sealevelstdtmp_k = co.c2k(15.0)
    theta0 = (temp_k/sealevelstdtmp_k) * (1 + (mach ** 2) * (GAMMA_DRY_AIR - 1)/2)
    return theta0


def tatbysat(mach, recfac=1.0):
    &#34;&#34;&#34;Ratio of total and static air temperature at a given Mach no&#34;&#34;&#34;
    return 1 + 0.5 * (GAMMA_DRY_AIR - 1) * recfac * (mach ** 2)


def pressratio(pressure_pa, mach):
    &#34;&#34;&#34;Ratio of total pressure and the standard SL pressure&#34;&#34;&#34;
    sealevelstdtpress_pa = 101325
    exp = GAMMA_DRY_AIR/(GAMMA_DRY_AIR - 1)
    delta0 = (pressure_pa/sealevelstdtpress_pa) * \
    (1 + (mach ** 2) * (GAMMA_DRY_AIR - 1)/2) ** exp
    return delta0


def turbofanthrustfactor(temp_c, pressure_pa, mach, \
throttleratio=1, ptype=&#34;highbpr&#34;):
    &#34;&#34;&#34;Multiply SL static thrust by this to get thrust at specified conditions&#34;&#34;&#34;

    # Model based on Mattingly et al.

    theta0 = tempratio(temp_c, mach)
    delta0 = pressratio(pressure_pa, mach)

    if ptype == &#34;highbpr&#34;: # high bypass ratio
        if theta0 &lt;= throttleratio:
            return delta0 * (1 - 0.49 * np.sqrt(mach))
        return delta0 * (1 - 0.49 * np.sqrt(mach) - 3 * (theta0 - throttleratio)/(1.5 + mach))

    if ptype == &#34;lowbpr&#34;: # low bypass, afterburner on
        if theta0 &lt;= throttleratio:
            return delta0
        return delta0 * (1 - 3.5 * (theta0 - throttleratio) / theta0)

    # low bypass, afterburner off
    if theta0 &lt;= throttleratio:
        return 0.6 * delta0
    return 0.6 * delta0 * (1 - 3.8 * (theta0 - throttleratio) / theta0)


def turbopropthrustfactor(temp_c, pressure_pa, mach, throttleratio=1):
    &#34;&#34;&#34;Multiply SL static thrust by this to get thrust at specified conditions&#34;&#34;&#34;

    # Model based on Mattingly et al.

    theta0 = tempratio(temp_c, mach)
    delta0 = pressratio(pressure_pa, mach)

    if mach &lt;= 0.1:
        return delta0

    if theta0 &lt;= throttleratio:
        return delta0 * (1 - 0.96 * (mach - 0.1) ** 0.25)
    return delta0 * (1 - 0.96 * (mach - 0.1) ** 0.25 - \
3 * (theta0 - throttleratio) / (8.13 * (mach - 0.1)))


def turbojetthrustfactor(temp_c, pressure_pa, mach, \
throttleratio=1, afterburner=False):
    &#34;&#34;&#34;Multiply SL static thrust by this to get thrust at specified conditions&#34;&#34;&#34;

    # Model based on Mattingly et al.

    theta0 = tempratio(temp_c, mach)
    delta0 = pressratio(pressure_pa, mach)

    if afterburner:
        if theta0 &lt;= throttleratio:
            return delta0 * (1 - 0.3 * (theta0 - 1) - 0.1 * np.sqrt(mach))
        return delta0 * (1 - 0.3 * (theta0 - 1) - 0.1 * np.sqrt(mach) - \
        1.5 * (theta0 - throttleratio) / throttleratio)

    if theta0 &lt;= throttleratio:
        return delta0 * 0.8 * (1 - 0.16 * np.sqrt(mach))
    return delta0 * 0.8 * (1 - 0.16 * np.sqrt(mach) - \
24 * (theta0 - throttleratio) / ((9 + mach) * theta0))


def pistonpowerfactor(density_kgpm3):
    &#34;&#34;&#34;Gagg-Ferrar model. Multiply by this to get power at given density.&#34;&#34;&#34;

    # Density ratio
    sigma = density_kgpm3 / 1.225
    return 1.132 * sigma - 0.132</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ADRpy.atmospheres.geom2geop45m"><code class="name flex">
<span>def <span class="ident">geom2geop45m</span></span>(<span>altitude_m)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert geometric height to geopotential (m) assuming 45deg lat</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geom2geop45m(altitude_m):
    &#34;&#34;&#34;Convert geometric height to geopotential (m) assuming 45deg lat&#34;&#34;&#34;
    return R_EARTH_M * altitude_m / (R_EARTH_M + altitude_m)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.geop2geom45m"><code class="name flex">
<span>def <span class="ident">geop2geom45m</span></span>(<span>altitude_m)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert geometric height to geopotential (m) assuming 45deg lat</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def geop2geom45m(altitude_m):
    &#34;&#34;&#34;Convert geometric height to geopotential (m) assuming 45deg lat&#34;&#34;&#34;
    return R_EARTH_M * altitude_m / (R_EARTH_M - altitude_m)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.idealgasdens_kgm3"><code class="name flex">
<span>def <span class="ident">idealgasdens_kgm3</span></span>(<span>p_pa, temp_k)</span>
</code></dt>
<dd>
<section class="desc"><p>Density from pressure and temperature, on ideal gas assumption</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def idealgasdens_kgm3(p_pa, temp_k):
    &#34;&#34;&#34;Density from pressure and temperature, on ideal gas assumption&#34;&#34;&#34;
    return p_pa / R_JPKGPK / temp_k</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.idealgaspress_pa"><code class="name flex">
<span>def <span class="ident">idealgaspress_pa</span></span>(<span>rho_kgpm3, temp_k)</span>
</code></dt>
<dd>
<section class="desc"><p>Pressure from density and temperature, on ideal gas assumption</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def idealgaspress_pa(rho_kgpm3, temp_k):
    &#34;&#34;&#34;Pressure from density and temperature, on ideal gas assumption&#34;&#34;&#34;
    return R_JPKGPK * rho_kgpm3 * temp_k</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.mil_hdbk_310"><code class="name flex">
<span>def <span class="ident">mil_hdbk_310</span></span>(<span>high_or_low, temp_or_dens, alt_km)</span>
</code></dt>
<dd>
<section class="desc"><p>Load an atmospheric data set from US Military Handbook 310</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def mil_hdbk_310(high_or_low, temp_or_dens, alt_km):
    &#34;&#34;&#34;Load an atmospheric data set from US Military Handbook 310&#34;&#34;&#34;

    m310name = high_or_low + &#39;_&#39; + temp_or_dens \
    + &#39;_at_&#39; + str(alt_km) + &#39;km.m310&#39;

    _fstr = os.path.join(os.path.dirname(__file__), &#34;data&#34;,
                         &#34;_MHDBK310&#34;, m310name)

    # Also looking for m310 files in the current directory if not found
    # in a dedicated _MHDBK310 folder
    if not os.path.isfile(_fstr):
        _fstr = high_or_low + &#39;_&#39; + temp_or_dens \
        + &#39;_at_&#39; + str(alt_km) + &#39;km.m310&#39;

    try:
        if temp_or_dens == &#39;temp&#39;:
            alt_km, t_1pct_k, rho_1pct_kgpm3, t_10pct_k, rho_10pct_kgpm3 = \
            np.loadtxt(_fstr, skiprows=0, unpack=True)
        else:
            alt_km, rho_1pct_kgpm3, t_1pct_k, rho_10pct_kgpm3, t_10pct_k = \
            np.loadtxt(_fstr, skiprows=0, unpack=True)

        atm1pct = Obsprofile(alt_m=co.km2m(alt_km), temp_k=t_1pct_k, \
        rho_kgpm3=rho_1pct_kgpm3)
        atm10pct = Obsprofile(alt_m=co.km2m(alt_km), temp_k=t_10pct_k, \
        rho_kgpm3=rho_10pct_kgpm3)
        return atm1pct, atm10pct

    except FileNotFoundError:
        print(&#34;No atmosphere data file found for this combination of inputs.&#34;)
        return None, None</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.pistonpowerfactor"><code class="name flex">
<span>def <span class="ident">pistonpowerfactor</span></span>(<span>density_kgpm3)</span>
</code></dt>
<dd>
<section class="desc"><p>Gagg-Ferrar model. Multiply by this to get power at given density.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pistonpowerfactor(density_kgpm3):
    &#34;&#34;&#34;Gagg-Ferrar model. Multiply by this to get power at given density.&#34;&#34;&#34;

    # Density ratio
    sigma = density_kgpm3 / 1.225
    return 1.132 * sigma - 0.132</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.pressratio"><code class="name flex">
<span>def <span class="ident">pressratio</span></span>(<span>pressure_pa, mach)</span>
</code></dt>
<dd>
<section class="desc"><p>Ratio of total pressure and the standard SL pressure</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pressratio(pressure_pa, mach):
    &#34;&#34;&#34;Ratio of total pressure and the standard SL pressure&#34;&#34;&#34;
    sealevelstdtpress_pa = 101325
    exp = GAMMA_DRY_AIR/(GAMMA_DRY_AIR - 1)
    delta0 = (pressure_pa/sealevelstdtpress_pa) * \
    (1 + (mach ** 2) * (GAMMA_DRY_AIR - 1)/2) ** exp
    return delta0</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.reciprocalhdg"><code class="name flex">
<span>def <span class="ident">reciprocalhdg</span></span>(<span>heading_deg)</span>
</code></dt>
<dd>
<section class="desc"><p>The reciprocal of a heading in degrees</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def reciprocalhdg(heading_deg):
    &#34;&#34;&#34;The reciprocal of a heading in degrees&#34;&#34;&#34;
    if heading_deg + 180 &gt; 360:
        return heading_deg - 180
    return heading_deg + 180</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.tatbysat"><code class="name flex">
<span>def <span class="ident">tatbysat</span></span>(<span>mach, recfac=1.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Ratio of total and static air temperature at a given Mach no</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tatbysat(mach, recfac=1.0):
    &#34;&#34;&#34;Ratio of total and static air temperature at a given Mach no&#34;&#34;&#34;
    return 1 + 0.5 * (GAMMA_DRY_AIR - 1) * recfac * (mach ** 2)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.tempratio"><code class="name flex">
<span>def <span class="ident">tempratio</span></span>(<span>temp_c, mach)</span>
</code></dt>
<dd>
<section class="desc"><p>Ratio of total temperature and the standard SL temperature</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tempratio(temp_c, mach):
    &#34;&#34;&#34;Ratio of total temperature and the standard SL temperature&#34;&#34;&#34;
    temp_k = co.c2k(temp_c)
    sealevelstdtmp_k = co.c2k(15.0)
    theta0 = (temp_k/sealevelstdtmp_k) * (1 + (mach ** 2) * (GAMMA_DRY_AIR - 1)/2)
    return theta0</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.turbofanthrustfactor"><code class="name flex">
<span>def <span class="ident">turbofanthrustfactor</span></span>(<span>temp_c, pressure_pa, mach, throttleratio=1, ptype=&#39;highbpr&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiply SL static thrust by this to get thrust at specified conditions</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def turbofanthrustfactor(temp_c, pressure_pa, mach, \
throttleratio=1, ptype=&#34;highbpr&#34;):
    &#34;&#34;&#34;Multiply SL static thrust by this to get thrust at specified conditions&#34;&#34;&#34;

    # Model based on Mattingly et al.

    theta0 = tempratio(temp_c, mach)
    delta0 = pressratio(pressure_pa, mach)

    if ptype == &#34;highbpr&#34;: # high bypass ratio
        if theta0 &lt;= throttleratio:
            return delta0 * (1 - 0.49 * np.sqrt(mach))
        return delta0 * (1 - 0.49 * np.sqrt(mach) - 3 * (theta0 - throttleratio)/(1.5 + mach))

    if ptype == &#34;lowbpr&#34;: # low bypass, afterburner on
        if theta0 &lt;= throttleratio:
            return delta0
        return delta0 * (1 - 3.5 * (theta0 - throttleratio) / theta0)

    # low bypass, afterburner off
    if theta0 &lt;= throttleratio:
        return 0.6 * delta0
    return 0.6 * delta0 * (1 - 3.8 * (theta0 - throttleratio) / theta0)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.turbojetthrustfactor"><code class="name flex">
<span>def <span class="ident">turbojetthrustfactor</span></span>(<span>temp_c, pressure_pa, mach, throttleratio=1, afterburner=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiply SL static thrust by this to get thrust at specified conditions</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def turbojetthrustfactor(temp_c, pressure_pa, mach, \
throttleratio=1, afterburner=False):
    &#34;&#34;&#34;Multiply SL static thrust by this to get thrust at specified conditions&#34;&#34;&#34;

    # Model based on Mattingly et al.

    theta0 = tempratio(temp_c, mach)
    delta0 = pressratio(pressure_pa, mach)

    if afterburner:
        if theta0 &lt;= throttleratio:
            return delta0 * (1 - 0.3 * (theta0 - 1) - 0.1 * np.sqrt(mach))
        return delta0 * (1 - 0.3 * (theta0 - 1) - 0.1 * np.sqrt(mach) - \
        1.5 * (theta0 - throttleratio) / throttleratio)

    if theta0 &lt;= throttleratio:
        return delta0 * 0.8 * (1 - 0.16 * np.sqrt(mach))
    return delta0 * 0.8 * (1 - 0.16 * np.sqrt(mach) - \
24 * (theta0 - throttleratio) / ((9 + mach) * theta0))</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.turbopropthrustfactor"><code class="name flex">
<span>def <span class="ident">turbopropthrustfactor</span></span>(<span>temp_c, pressure_pa, mach, throttleratio=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiply SL static thrust by this to get thrust at specified conditions</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def turbopropthrustfactor(temp_c, pressure_pa, mach, throttleratio=1):
    &#34;&#34;&#34;Multiply SL static thrust by this to get thrust at specified conditions&#34;&#34;&#34;

    # Model based on Mattingly et al.

    theta0 = tempratio(temp_c, mach)
    delta0 = pressratio(pressure_pa, mach)

    if mach &lt;= 0.1:
        return delta0

    if theta0 &lt;= throttleratio:
        return delta0 * (1 - 0.96 * (mach - 0.1) ** 0.25)
    return delta0 * (1 - 0.96 * (mach - 0.1) ** 0.25 - \
3 * (theta0 - throttleratio) / (8.13 * (mach - 0.1)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ADRpy.atmospheres.Atmosphere"><code class="flex name class">
<span>class <span class="ident">Atmosphere</span></span>
</code></dt>
<dd>
<section class="desc"><p>Standard or off-standard/custom atmospheres.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Atmosphere:
    &#34;&#34;&#34;Standard or off-standard/custom atmospheres.&#34;&#34;&#34;

    # INTERNATIONAL STANDARD ATMOSPHERE CONSTANTS
    # _Level limits in m =======================================================
    _Level1 = 11000
    _Level2 = 20000
    _Level3 = 32000
    _Level4 = 47000
    _Level5 = 50000
    # _Level limits in terms of density (kg/m3)=================================
    _dLevel1 = 0.36391700650017816
    _dLevel2 = 0.088034556579455497
    _dLevel3 = 0.013224937668421609
    _dLevel4 = 0.0014275295197313882
    _dLevel5 = 0.00097752213943149563
    # _Level limits in terms of density (kg/m3)=================================
    _pLevel1 = 22632.000999016603
    _pLevel2 = 5474.8699475808515
    _pLevel3 = 868.01381950678511
    _pLevel4 = 110.90599734942646
    # ISA constants, base temperatures A in K, lapse rates B in deg/m
    # Based on Table 11.3, defined in terms of &#39;pressure height Hp&#39;, SI Units
    # Layer 1 ------------------------------------------------------------------
    _A1 = 288.15
    _B1 = -6.5e-3
    _C1 = 8.9619638
    _D1 = -0.20216125e-3
    _E1 = 5.2558797
    _I1 = 1.048840
    _J1 = -23.659414e-6
    _L1 = 4.2558797
    # Layer 2 -----------------------------------------------------------------
    _A2 = 216.65
    _B2 = 0
    _F2 = 128244.5
    _G2 = -0.15768852e-3
    _M2 = 2.0621400
    _N2 = -0.15768852e-3
    # Layer 3 -----------------------------------------------------------------
    _A3 = 196.65
    _B3 = 1e-3
    _C3 = 0.70551848
    _D3 = 3.5876861e-6
    _E3 = -34.163218
    _I3 = 0.9726309
    _J3 = 4.94600e-6
    _L3 = -35.163218
    # Layer 4 -----------------------------------------------------------------
    _A4 = 139.05
    _B4 = 2.8e-3
    _C4 = 0.34926867
    _D4 = 7.0330980e-6
    _E4 = -12.201149
    _I4 = 0.84392929
    _J4 = 16.993902e-6
    _L4 = -13.201149
    # Layer 5 -----------------------------------------------------------------
    _A5 = 270.65
    _B5 = 0
    _F5 = 41828.42
    _G5 = -0.12622656e-3
    _M5 = 0.53839563
    _N5 = -0.12622656e-3
    #==========================================================================



    def __init__(self, offset_deg=0, profile=None):

        self.offset_deg = offset_deg # Relative temperature (C or K)
        self.profile = profile

        # If an altitude vector is not specified...
        if not profile is None:
            self.is_isa = False # Interpolated atmosphere
        else:
            #...then we are building an ISA
            self.is_isa = True



    def _alttest(self, reqalt_m):

        if isinstance(reqalt_m, Number):
            reqalt_m = [reqalt_m]
        # Convert to Numpy array if list
        reqalt_m = np.array(reqalt_m)
        # Recast as float, as there is no sensible reason for integers
        reqalt_m = [x.astype(float) for x in reqalt_m]

        if self.is_isa:
            if any(x &gt; self._Level5 for x in reqalt_m):
                print(&#39;Altitudes had to be limited to 50km where higher.&#39;)
                reqalt_m[reqalt_m &gt; self._Level5] = self._Level5
        else:
            minalt_m = np.amin(self.profile.alt_m)
            maxalt_m = np.amax(self.profile.alt_m)
            if any(reqalt_m &lt; minalt_m):
                print(&#39;Requested altitude below interpolation range.&#39;)
                reqalt_m[reqalt_m &lt; minalt_m] = minalt_m
            if any(reqalt_m &gt; maxalt_m):
                print(&#39;Requested altitude above interpolation range.&#39;)
                reqalt_m[reqalt_m &gt; maxalt_m] = maxalt_m

        return reqalt_m


    def _isatemp_k(self, altitude_m):
        &#34;&#34;&#34;ISA temperature as a function of geopotential altitude&#34;&#34;&#34;
        alt_it = np.nditer([altitude_m, None])
        for alt, t_k in alt_it:
            if alt &lt; self._Level1:
                # Troposphere, temperature decreases linearly
                t_k[...] = self._A1 + self._B1 * alt
            elif alt &lt; self._Level2:
                # Lower stratopshere, temperature is constant
                t_k[...] = self._A2 + self._B2 * alt
            elif alt &lt; self._Level3:
                # Upper stratopshere, temperature is increasing
                t_k[...] = self._A3 + self._B3 * alt
            elif alt &lt; self._Level4:
                # Between 32 and 47 km
                t_k[...] = self._A4 + self._B4 * alt
            else:
                # Between 47km and 51km
                t_k[...] = self._A5 + self._B5 * alt
            # Adjust for the temperature offset
            t_k[...] = t_k[...] + self.offset_deg
        return alt_it.operands[1]


    def _isapress_pa(self, altitude_m):
        &#34;&#34;&#34;ISA pressure as a function of geopotential altitude&#34;&#34;&#34;
        alt_it = np.nditer([altitude_m, None])
        for alt, pressure_pa in alt_it:
            if alt &lt; self._Level1:
                # Troposphere
                pressure_pa[...] = (self._C1 + self._D1 * alt) ** self._E1
            elif alt &lt; self._Level2:
                # Lower stratopshere
                pressure_pa[...] = self._F2 * math.exp(self._G2 * alt)
            elif alt &lt; self._Level3:
                # Upper stratopshere
                pressure_pa[...] = (self._C3 + self._D3 * alt) ** self._E3
            elif alt &lt; self._Level4:
                # Between 32 and 47 km
                pressure_pa[...] = (self._C4 + self._D4 * alt) ** self._E4
            else:
                # Between 47km and 51km
                pressure_pa[...] = self._F5 * math.exp(self._G5 * alt)
        return alt_it.operands[1]


    def _isapressalt_m(self, pressure_pa):
        &#34;&#34;&#34;Returns the geopotential alt (m) at which ISA has the given pressure&#34;&#34;&#34;
        press_it = np.nditer([pressure_pa, None])
        for press_pa, alt_m in press_it:
            if press_pa &gt; self._pLevel1:
                # Troposphere
                alt_m[...] = (press_pa ** (1 / self._E1) - self._C1) / self._D1
            elif press_pa &gt; self._pLevel2:
                # Lower stratopshere
                alt_m[...] = (1 / self._G2) * math.log1p(press_pa / self._F2 - 1)
            elif press_pa &gt; self._pLevel3:
                # Upper stratopshere
                alt_m[...] = (press_pa ** (1 / self._E3) - self._C3) / self._D3
            elif press_pa &gt; self._pLevel4:
                # Between 32 and 47 km
                alt_m[...] = (press_pa ** (1 / self._E4) - self._C4) / self._D4
            else:
                # Between 47km and 51km
                alt_m[...] = (1 / self._G5) * math.log1p(press_pa / self._F5 - 1)
        return press_it.operands[1]


    def _isadens_kgpm3(self, altitude_m):
        &#34;&#34;&#34;ISA density as a function of geopotential altitude&#34;&#34;&#34;
        alt_it = np.nditer([altitude_m, None])
        for alt, dens_kgpm3 in alt_it:
            if alt &lt; self._Level1:
                # Troposphere
                dens_kgpm3[...] = (self._I1 + self._J1 * alt) ** self._L1
            elif alt &lt; self._Level2:
                # Lower stratopshere
                dens_kgpm3[...] = self._M2 * math.exp(self._N2 * alt)
            elif alt &lt; self._Level3:
                # Upper stratopshere
                dens_kgpm3[...] = (self._I3 + self._J3 * alt) ** self._L3
            elif alt &lt; self._Level4:
                # Between 32 and 47 km
                dens_kgpm3[...] = (self._I4 + self._J4 * alt) ** self._L4
            else:
                # Between 47km and 51km
                dens_kgpm3[...] = self._M5 * math.exp(self._N5 * alt)
            # Adjust for the temperature offset
            dens_kgpm3[...] = \
            dens_kgpm3[...] / (1 + self.offset_deg / (self._isatemp_k(alt) - self.offset_deg))

        return alt_it.operands[1]


    def _isadensalt_m(self, dens_kgpm3):
        &#34;&#34;&#34;Returns the geopotential alt (m) at which ISA has given density (kg/m^3)&#34;&#34;&#34;
        dense_it = np.nditer([dens_kgpm3, None])
        for d_kgpm3, alt_m in dense_it:
            if d_kgpm3 &gt; self._dLevel1:
                # Troposphere
                alt_m[...] = (d_kgpm3 ** (1 / self._L1) - self._I1) / self._J1
            elif d_kgpm3 &gt; self._dLevel2:
                # Lower stratopshere
                alt_m[...] = (1 / self._N2) * math.log1p(dens_kgpm3 / self._M2 - 1)
            elif d_kgpm3 &gt; self._dLevel3:
                # Upper stratopshere
                alt_m[...] = (d_kgpm3 ** (1 / self._L3) - self._I3) / self._J3
            elif dens_kgpm3 &gt; self._dLevel4:
                # Between 32 and 47 km
                alt_m[...] = (d_kgpm3 ** (1 / self._L4) - self._I4) / self._J4
            else:
                # Between 47km and 51km
                alt_m[...] = (1 / self._N5) * math.log1p(d_kgpm3 / self._M5 - 1)
            # Adjust for the temperature offset
        return dense_it.operands[1]


    def airtemp_k(self, altitudes_m=0):
        &#34;&#34;&#34;Temperatures in the selected atmosphere, in K.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        if self.is_isa:
            temperatures_k = self._isatemp_k(altitudes_m)
        else:
            temperatures_k = self.profile.ftemp_k(altitudes_m)
        return _reverttoscalar(temperatures_k)


    def airpress_pa(self, altitudes_m=0):
        &#34;&#34;&#34;Pressures in the selected atmosphere, in Pa.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        if self.is_isa:
            pressures_pa = self._isapress_pa(altitudes_m)
        else:
            pressures_pa = self.profile.fp_pa(altitudes_m)
        return _reverttoscalar(pressures_pa)


    def vsound_mps(self, altitudes_m=0):
        &#34;&#34;&#34;Speed of sound in m/s at an altitude given in m.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        temperatures_k = self.airtemp_k(altitudes_m)
        vsounds_mps = _vsound_mps(temperatures_k)
        return _reverttoscalar(vsounds_mps)


    def airdens_kgpm3(self, altitudes_m=0):
        &#34;&#34;&#34;Density in kg/m^3.&#34;&#34;&#34;
        altitudes_m = self._alttest(altitudes_m)
        if self.is_isa:
            densities_kgpm3 = self._isadens_kgpm3(altitudes_m)
        else:
            densities_kgpm3 = self.profile.frho_kgpm3(altitudes_m)
        return _reverttoscalar(densities_kgpm3)


    def mach(self, airspeed_mps, altitude_m=0):
        &#34;&#34;&#34;Mach number at a given speed (m/s) and altitude (m)&#34;&#34;&#34;

        # Check altitude range
        altitude_m = self._alttest(altitude_m)

        # Compute speed of sound at the given altitude(s)
        vs_mps = self.vsound_mps(altitude_m)

        return airspeed_mps / vs_mps


    def vsound_kts(self, altitudes_m=0):
        &#34;&#34;&#34;Speed of sound in knots.&#34;&#34;&#34;
        return co.mps2kts(self.vsound_mps(altitudes_m))


    def airpress_mbar(self, altitudes_m=0):
        &#34;&#34;&#34;Air pressure in mbar.&#34;&#34;&#34;
        return co.pa2mbar(self.airpress_pa(altitudes_m))


    def airtemp_c(self, altitudes_m=0):
        &#34;&#34;&#34;Air temperature in Celsius.&#34;&#34;&#34;
        return co.k2c(self.airtemp_k(altitudes_m))


    def dynamicpressure_pa(self, airspeed_mps=0, altitudes_m=0):
        &#34;&#34;&#34;Dynamic pressure in the current atmosphere at a given true airspeed and altitude

        `PARAMETERS`
        ------------

        `airspeed_mps` : float, true airspeed in m/s (MPSTAS)

        `altitudes_m`: float array, altitudes in m where the dynamic pressure is to be computed


        `RETURNS`
        -----------

        float or array of floats, dynamic pressure values

        `EXAMPLE`
        -----------

        ```python
        from ADRpy import atmospheres as at
        from ADRpy import unitconversions as co

        ISA = at.Atmosphere()

        altitudelist_m = [0, 500, 1000, 1500]

        MPSTAS = 20

        q_Pa = ISA.dynamicpressure_pa(MPSTAS, altitudelist_m)

        q_mbar = co.pa2mbar(q_Pa)

        print(q_mbar)
        ```
        -----------
        ```python
        [ 2.44999974  2.33453737  2.22328473  2.11613426]
        ```
        &#34;&#34;&#34;

        return 0.5 * self.airdens_kgpm3(altitudes_m) * (airspeed_mps ** 2)


    def eas2tas(self, eas, altitude_m):
        &#34;&#34;&#34;Convert EAS to TAS at a given altitude&#34;&#34;&#34;
        dratio = self.airdens_kgpm3(altitude_m) / self.airdens_kgpm3(0)
        return eas / math.sqrt(dratio)

    def tas2eas(self, tas, altitude_m):
        &#34;&#34;&#34;Convert TAS to EAS at a given altitude&#34;&#34;&#34;
        dratio = self.airdens_kgpm3(altitude_m) / self.airdens_kgpm3(0)
        return tas * math.sqrt(dratio)

    def mpseas2mpscas(self, mpseas, altitude_m):
        &#34;&#34;&#34;Convert EAS (m/s) to CAS (m/s) at a given altitude (m)&#34;&#34;&#34;
        # Note: unit specific, as the calculation requires Mach no.
        mpstas = self.eas2tas(mpseas, altitude_m)
        machno = self.mach(mpstas, altitude_m)
        delta = self.airpress_pa(altitude_m) / self.airpress_pa()
        m2_term = (1.0 / 8.0) * (1 - delta) * (machno ** 2)
        m4_term = (3.0 / 640.0) * (1 - 10 * delta + 9 * (delta**2)) * (machno ** 4)
        return mpseas * (1 + m2_term + m4_term), machno

    def keas2kcas(self, keas, altitude_m):
        &#34;&#34;&#34;Converts equivalent airspeed into calibrated airspeed.

        `PARAMETERS`
        ------------

        `keas` : float or numpy array, equivalent airspeed in knots.

        `altitude_m` : float, altitude in metres.

        `RETURNS`
        -----------

        `kcas` : float or numpy array, calibrated airspeed in knots.

        `mach` : float, Mach number.

        `SEE ALSO`
        ------------
        ``mpseas2mpscas``

        `NOTES`
        ---------
        The reverse conversion is slightly more complicated, as their relationship
        depends on the Mach number. This, in turn, requires the computation of the
        true airspeed and that can only be computed from EAS, not CAS. The unit-
        specific nature of the function is also the result of the need for computing
        the Mach number.

        `EXAMPLE`
        ------------

        ```python
        import numpy as np
        from ADRpy import atmospheres as at
        from ADRpy import unitconversions as co

        isa = at.Atmosphere()

        keas = np.array([100, 200, 300])
        altitude_m = co.feet2m(40000)

        kcas, mach = isa.keas2kcas(keas, altitude_m)

        print(kcas)
        ```
        ---
        ```python
        [ 101.25392563  209.93839073  333.01861569]
        ```
        &#34;&#34;&#34;
        # Note: unit specific, as the calculation requires Mach no.
        np.asarray(keas)
        mpseas = co.kts2mps(keas)
        mpscas, machno = self.mpseas2mpscas(mpseas, altitude_m)
        kcas = co.mps2kts(mpscas)
        return kcas, machno</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ADRpy.atmospheres.Atmosphere.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, offset_deg=0, profile=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, offset_deg=0, profile=None):

    self.offset_deg = offset_deg # Relative temperature (C or K)
    self.profile = profile

    # If an altitude vector is not specified...
    if not profile is None:
        self.is_isa = False # Interpolated atmosphere
    else:
        #...then we are building an ISA
        self.is_isa = True</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.airdens_kgpm3"><code class="name flex">
<span>def <span class="ident">airdens_kgpm3</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Density in kg/m^3.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def airdens_kgpm3(self, altitudes_m=0):
    &#34;&#34;&#34;Density in kg/m^3.&#34;&#34;&#34;
    altitudes_m = self._alttest(altitudes_m)
    if self.is_isa:
        densities_kgpm3 = self._isadens_kgpm3(altitudes_m)
    else:
        densities_kgpm3 = self.profile.frho_kgpm3(altitudes_m)
    return _reverttoscalar(densities_kgpm3)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.airpress_mbar"><code class="name flex">
<span>def <span class="ident">airpress_mbar</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Air pressure in mbar.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def airpress_mbar(self, altitudes_m=0):
    &#34;&#34;&#34;Air pressure in mbar.&#34;&#34;&#34;
    return co.pa2mbar(self.airpress_pa(altitudes_m))</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.airpress_pa"><code class="name flex">
<span>def <span class="ident">airpress_pa</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Pressures in the selected atmosphere, in Pa.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def airpress_pa(self, altitudes_m=0):
    &#34;&#34;&#34;Pressures in the selected atmosphere, in Pa.&#34;&#34;&#34;
    altitudes_m = self._alttest(altitudes_m)
    if self.is_isa:
        pressures_pa = self._isapress_pa(altitudes_m)
    else:
        pressures_pa = self.profile.fp_pa(altitudes_m)
    return _reverttoscalar(pressures_pa)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.airtemp_c"><code class="name flex">
<span>def <span class="ident">airtemp_c</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Air temperature in Celsius.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def airtemp_c(self, altitudes_m=0):
    &#34;&#34;&#34;Air temperature in Celsius.&#34;&#34;&#34;
    return co.k2c(self.airtemp_k(altitudes_m))</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.airtemp_k"><code class="name flex">
<span>def <span class="ident">airtemp_k</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Temperatures in the selected atmosphere, in K.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def airtemp_k(self, altitudes_m=0):
    &#34;&#34;&#34;Temperatures in the selected atmosphere, in K.&#34;&#34;&#34;
    altitudes_m = self._alttest(altitudes_m)
    if self.is_isa:
        temperatures_k = self._isatemp_k(altitudes_m)
    else:
        temperatures_k = self.profile.ftemp_k(altitudes_m)
    return _reverttoscalar(temperatures_k)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.dynamicpressure_pa"><code class="name flex">
<span>def <span class="ident">dynamicpressure_pa</span></span>(<span>self, airspeed_mps=0, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Dynamic pressure in the current atmosphere at a given true airspeed and altitude</p>
<h2 id="parameters"><code>PARAMETERS</code></h2>
<p><code>airspeed_mps</code> : float, true airspeed in m/s (MPSTAS)</p>
<p><code>altitudes_m</code>: float array, altitudes in m where the dynamic pressure is to be computed</p>
<h2 id="returns"><code>RETURNS</code></h2>
<p>float or array of floats, dynamic pressure values</p>
<h2 id="example"><code>EXAMPLE</code></h2>
<pre><code class="python">from ADRpy import atmospheres as at
from ADRpy import unitconversions as co

ISA = at.Atmosphere()

altitudelist_m = [0, 500, 1000, 1500]

MPSTAS = 20

q_Pa = ISA.dynamicpressure_pa(MPSTAS, altitudelist_m)

q_mbar = co.pa2mbar(q_Pa)

print(q_mbar)
</code></pre>
<hr>
<pre><code class="python">[ 2.44999974  2.33453737  2.22328473  2.11613426]
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def dynamicpressure_pa(self, airspeed_mps=0, altitudes_m=0):
    &#34;&#34;&#34;Dynamic pressure in the current atmosphere at a given true airspeed and altitude

    `PARAMETERS`
    ------------

    `airspeed_mps` : float, true airspeed in m/s (MPSTAS)

    `altitudes_m`: float array, altitudes in m where the dynamic pressure is to be computed


    `RETURNS`
    -----------

    float or array of floats, dynamic pressure values

    `EXAMPLE`
    -----------

    ```python
    from ADRpy import atmospheres as at
    from ADRpy import unitconversions as co

    ISA = at.Atmosphere()

    altitudelist_m = [0, 500, 1000, 1500]

    MPSTAS = 20

    q_Pa = ISA.dynamicpressure_pa(MPSTAS, altitudelist_m)

    q_mbar = co.pa2mbar(q_Pa)

    print(q_mbar)
    ```
    -----------
    ```python
    [ 2.44999974  2.33453737  2.22328473  2.11613426]
    ```
    &#34;&#34;&#34;

    return 0.5 * self.airdens_kgpm3(altitudes_m) * (airspeed_mps ** 2)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.eas2tas"><code class="name flex">
<span>def <span class="ident">eas2tas</span></span>(<span>self, eas, altitude_m)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert EAS to TAS at a given altitude</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def eas2tas(self, eas, altitude_m):
    &#34;&#34;&#34;Convert EAS to TAS at a given altitude&#34;&#34;&#34;
    dratio = self.airdens_kgpm3(altitude_m) / self.airdens_kgpm3(0)
    return eas / math.sqrt(dratio)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.keas2kcas"><code class="name flex">
<span>def <span class="ident">keas2kcas</span></span>(<span>self, keas, altitude_m)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts equivalent airspeed into calibrated airspeed.</p>
<h2 id="parameters"><code>PARAMETERS</code></h2>
<p><code>keas</code> : float or numpy array, equivalent airspeed in knots.</p>
<p><code>altitude_m</code> : float, altitude in metres.</p>
<h2 id="returns"><code>RETURNS</code></h2>
<p><code>kcas</code> : float or numpy array, calibrated airspeed in knots.</p>
<p><code>mach</code> : float, Mach number.</p>
<h2 id="see-also"><code>SEE ALSO</code></h2>
<p><code>mpseas2mpscas</code></p>
<h2 id="notes"><code>NOTES</code></h2>
<p>The reverse conversion is slightly more complicated, as their relationship
depends on the Mach number. This, in turn, requires the computation of the
true airspeed and that can only be computed from EAS, not CAS. The unit-
specific nature of the function is also the result of the need for computing
the Mach number.</p>
<h2 id="example"><code>EXAMPLE</code></h2>
<pre><code class="python">import numpy as np
from ADRpy import atmospheres as at
from ADRpy import unitconversions as co

isa = at.Atmosphere()

keas = np.array([100, 200, 300])
altitude_m = co.feet2m(40000)

kcas, mach = isa.keas2kcas(keas, altitude_m)

print(kcas)
</code></pre>
<hr>
<pre><code class="python">[ 101.25392563  209.93839073  333.01861569]
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def keas2kcas(self, keas, altitude_m):
    &#34;&#34;&#34;Converts equivalent airspeed into calibrated airspeed.

    `PARAMETERS`
    ------------

    `keas` : float or numpy array, equivalent airspeed in knots.

    `altitude_m` : float, altitude in metres.

    `RETURNS`
    -----------

    `kcas` : float or numpy array, calibrated airspeed in knots.

    `mach` : float, Mach number.

    `SEE ALSO`
    ------------
    ``mpseas2mpscas``

    `NOTES`
    ---------
    The reverse conversion is slightly more complicated, as their relationship
    depends on the Mach number. This, in turn, requires the computation of the
    true airspeed and that can only be computed from EAS, not CAS. The unit-
    specific nature of the function is also the result of the need for computing
    the Mach number.

    `EXAMPLE`
    ------------

    ```python
    import numpy as np
    from ADRpy import atmospheres as at
    from ADRpy import unitconversions as co

    isa = at.Atmosphere()

    keas = np.array([100, 200, 300])
    altitude_m = co.feet2m(40000)

    kcas, mach = isa.keas2kcas(keas, altitude_m)

    print(kcas)
    ```
    ---
    ```python
    [ 101.25392563  209.93839073  333.01861569]
    ```
    &#34;&#34;&#34;
    # Note: unit specific, as the calculation requires Mach no.
    np.asarray(keas)
    mpseas = co.kts2mps(keas)
    mpscas, machno = self.mpseas2mpscas(mpseas, altitude_m)
    kcas = co.mps2kts(mpscas)
    return kcas, machno</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.mach"><code class="name flex">
<span>def <span class="ident">mach</span></span>(<span>self, airspeed_mps, altitude_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Mach number at a given speed (m/s) and altitude (m)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def mach(self, airspeed_mps, altitude_m=0):
    &#34;&#34;&#34;Mach number at a given speed (m/s) and altitude (m)&#34;&#34;&#34;

    # Check altitude range
    altitude_m = self._alttest(altitude_m)

    # Compute speed of sound at the given altitude(s)
    vs_mps = self.vsound_mps(altitude_m)

    return airspeed_mps / vs_mps</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.mpseas2mpscas"><code class="name flex">
<span>def <span class="ident">mpseas2mpscas</span></span>(<span>self, mpseas, altitude_m)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert EAS (m/s) to CAS (m/s) at a given altitude (m)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def mpseas2mpscas(self, mpseas, altitude_m):
    &#34;&#34;&#34;Convert EAS (m/s) to CAS (m/s) at a given altitude (m)&#34;&#34;&#34;
    # Note: unit specific, as the calculation requires Mach no.
    mpstas = self.eas2tas(mpseas, altitude_m)
    machno = self.mach(mpstas, altitude_m)
    delta = self.airpress_pa(altitude_m) / self.airpress_pa()
    m2_term = (1.0 / 8.0) * (1 - delta) * (machno ** 2)
    m4_term = (3.0 / 640.0) * (1 - 10 * delta + 9 * (delta**2)) * (machno ** 4)
    return mpseas * (1 + m2_term + m4_term), machno</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.tas2eas"><code class="name flex">
<span>def <span class="ident">tas2eas</span></span>(<span>self, tas, altitude_m)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert TAS to EAS at a given altitude</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tas2eas(self, tas, altitude_m):
    &#34;&#34;&#34;Convert TAS to EAS at a given altitude&#34;&#34;&#34;
    dratio = self.airdens_kgpm3(altitude_m) / self.airdens_kgpm3(0)
    return tas * math.sqrt(dratio)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.vsound_kts"><code class="name flex">
<span>def <span class="ident">vsound_kts</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Speed of sound in knots.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def vsound_kts(self, altitudes_m=0):
    &#34;&#34;&#34;Speed of sound in knots.&#34;&#34;&#34;
    return co.mps2kts(self.vsound_mps(altitudes_m))</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Atmosphere.vsound_mps"><code class="name flex">
<span>def <span class="ident">vsound_mps</span></span>(<span>self, altitudes_m=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Speed of sound in m/s at an altitude given in m.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def vsound_mps(self, altitudes_m=0):
    &#34;&#34;&#34;Speed of sound in m/s at an altitude given in m.&#34;&#34;&#34;
    altitudes_m = self._alttest(altitudes_m)
    temperatures_k = self.airtemp_k(altitudes_m)
    vsounds_mps = _vsound_mps(temperatures_k)
    return _reverttoscalar(vsounds_mps)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ADRpy.atmospheres.Obsprofile"><code class="flex name class">
<span>class <span class="ident">Obsprofile</span></span>
</code></dt>
<dd>
<section class="desc"><p>Observed atmosphere profile data.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Obsprofile:
    &#34;&#34;&#34;Observed atmosphere profile data.&#34;&#34;&#34;

    def __init__(self, alt_m=None, temp_k=None, rho_kgpm3=None, p_pa=None):

        self.alt_m = np.array(alt_m)

        self.temp_k = np.array(temp_k)
        self.rho_kgpm3 = np.array(rho_kgpm3)
        self.p_pa = np.array(p_pa)

        # Check and complete the data table and build the interp functions

        # temperature (K) and density are given against an altitude scale
        if np.size(self.alt_m) == np.size(self.temp_k) == np.size(self.rho_kgpm3):
            self.p_pa = R_JPKGPK * self.rho_kgpm3 * self.temp_k
        # temperature (K) and pressure are given against an altitude scale
        elif np.size(self.alt_m) == np.size(self.temp_k) == np.size(self.p_pa):
            self.rho_kgpm3 = idealgasdens_kgm3(self.p_pa, self.temp_k)
        # speed of sound
        self.vs_mps = \
        [math.sqrt(1.4 * R_JPKGPK * T) for T in self.temp_k]

        # all data points ready, the interpolators can now be constructed
        self.ftemp_k = interpolate.interp1d(self.alt_m, self.temp_k)
        self.fp_pa = interpolate.interp1d(self.alt_m, self.p_pa)
        self.frho_kgpm3 = interpolate.interp1d(self.alt_m, self.rho_kgpm3)
        self.fvs_mps = interpolate.interp1d(self.alt_m, self.vs_mps)

    def loalt(self):
        &#34;&#34;&#34;The minimum valid altitude (in m) of the interpolators.&#34;&#34;&#34;
        return min(self.alt_m)

    def hialt(self):
        &#34;&#34;&#34;The maximum valid altitude (in m) of the interpolators.&#34;&#34;&#34;
        return max(self.alt_m)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ADRpy.atmospheres.Obsprofile.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, alt_m=None, temp_k=None, rho_kgpm3=None, p_pa=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, alt_m=None, temp_k=None, rho_kgpm3=None, p_pa=None):

    self.alt_m = np.array(alt_m)

    self.temp_k = np.array(temp_k)
    self.rho_kgpm3 = np.array(rho_kgpm3)
    self.p_pa = np.array(p_pa)

    # Check and complete the data table and build the interp functions

    # temperature (K) and density are given against an altitude scale
    if np.size(self.alt_m) == np.size(self.temp_k) == np.size(self.rho_kgpm3):
        self.p_pa = R_JPKGPK * self.rho_kgpm3 * self.temp_k
    # temperature (K) and pressure are given against an altitude scale
    elif np.size(self.alt_m) == np.size(self.temp_k) == np.size(self.p_pa):
        self.rho_kgpm3 = idealgasdens_kgm3(self.p_pa, self.temp_k)
    # speed of sound
    self.vs_mps = \
    [math.sqrt(1.4 * R_JPKGPK * T) for T in self.temp_k]

    # all data points ready, the interpolators can now be constructed
    self.ftemp_k = interpolate.interp1d(self.alt_m, self.temp_k)
    self.fp_pa = interpolate.interp1d(self.alt_m, self.p_pa)
    self.frho_kgpm3 = interpolate.interp1d(self.alt_m, self.rho_kgpm3)
    self.fvs_mps = interpolate.interp1d(self.alt_m, self.vs_mps)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Obsprofile.hialt"><code class="name flex">
<span>def <span class="ident">hialt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The maximum valid altitude (in m) of the interpolators.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hialt(self):
    &#34;&#34;&#34;The maximum valid altitude (in m) of the interpolators.&#34;&#34;&#34;
    return max(self.alt_m)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Obsprofile.loalt"><code class="name flex">
<span>def <span class="ident">loalt</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The minimum valid altitude (in m) of the interpolators.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def loalt(self):
    &#34;&#34;&#34;The minimum valid altitude (in m) of the interpolators.&#34;&#34;&#34;
    return min(self.alt_m)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ADRpy.atmospheres.Runway"><code class="flex name class">
<span>class <span class="ident">Runway</span></span>
</code></dt>
<dd>
<section class="desc"><p>Parameters and methods of runway definition</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Runway:
    &#34;&#34;&#34;Parameters and methods of runway definition&#34;&#34;&#34;

    def __init__(self, icao_code=None, rwyno=0,
                 elevation_ft=0, heading=0, surf=&#39;ASP&#39;,
                 length_ft=10000, width_ft=100):
        if icao_code:
            # Read relevant runway data from the ourairports.com database
            # le_... / he_... - numbers referring to the low/high end respectively
            rwy_file = os.path.join(os.path.dirname(__file__), &#34;data&#34;, &#34;runways.csv&#34;)
            with open(rwy_file, newline=&#39;&#39;) as rwyfile:
                runwaydata = csv.reader(rwyfile, delimiter=&#39;,&#39;)
                runwaylist = []
                for row in runwaydata:
                    runwaylist.append(row)
            rindlst = [i for i, rwy in enumerate(runwaylist) if rwy[2] == icao_code]
            rind = rindlst[0]
            self.ident = runwaylist[rind + rwyno][0]
            self.airport_ref = runwaylist[rind + rwyno][1]
            self.airport_ident = runwaylist[rind + rwyno][2]
            self.length_ft = float(runwaylist[rind + rwyno][3])
            self.width_ft = float(runwaylist[rind + rwyno][4])
            self.surface = runwaylist[rind + rwyno][5]
            self.lighted = runwaylist[rind + rwyno][6]
            self.closed = runwaylist[rind + rwyno][7]
            self.le_ident = runwaylist[rind + rwyno][8]
            self.le_latitude_deg = runwaylist[rind + rwyno][9]
            self.le_longitude_deg = runwaylist[rind + rwyno][10]
            self.le_elevation_ft = float(runwaylist[rind + rwyno][11])
            self.le_heading_degt = float(runwaylist[rind + rwyno][12])
            try:
                self.le_displaced_threshold_ft = float(runwaylist[rind + rwyno][13])
            except ValueError:
                self.le_displaced_threshold_ft = float(&#39;nan&#39;)
            self.he_ident = runwaylist[rind + rwyno][14]
            self.he_latitude_deg = runwaylist[rind + rwyno][15]
            self.he_longitude_deg = runwaylist[rind + rwyno][16]
            self.he_elevation_ft = float(runwaylist[rind + rwyno][17])
            self.he_heading_degt = float(runwaylist[rind + rwyno][18])
            try:
                self.he_displaced_threshold_ft = float(runwaylist[rind + rwyno][19])
            except ValueError:
                self.he_displaced_threshold_ft = float(&#39;nan&#39;)
        else:
            # Define a custom runway based on the data provided
            self.ident = &#39;0000000&#39;
            self.airport_ref = &#39;0000&#39;
            self.airport_ident = &#39;CUST&#39;
            self.length_ft = length_ft
            self.width_ft = width_ft
            self.surface = surf
            self.lighted = 1
            self.closed = 0
            self.le_ident = str(int(heading/10))
            self.le_latitude_deg = 0
            self.le_longitude_deg = 0
            self.le_elevation_ft = elevation_ft
            self.le_heading_degt = str(heading)
            self.le_displaced_threshold_ft = 0
            self.he_ident = str(int(reciprocalhdg(heading)/10))
            self.he_latitude_deg = 0
            self.he_longitude_deg = 0
            self.he_elevation_ft = elevation_ft
            self.he_heading_degt = str(reciprocalhdg(heading))
            self.he_displaced_threshold_ft = 0

        # Metric versions of the imperial fields listed above
        self.length_m = co.feet2m(self.length_ft)
        self.width_m = co.feet2m(self.width_ft)
        self.le_elevation_m = co.feet2m(self.le_elevation_ft)
        self.le_displaced_threshold_m = co.feet2m(self.le_displaced_threshold_ft)
        self.he_elevation_m = co.feet2m(self.he_elevation_ft)
        self.he_displaced_threshold_m = co.feet2m(self.he_displaced_threshold_ft)


    def windcomponents(self, wind_dirs_deg, wind_speeds):
        &#34;&#34;&#34;Resolves list of wind speeds and directions into runway/cross components&#34;&#34;&#34;

        speeds = mtools.recastasnpfloatarray(wind_speeds)

        # Wind speed is considered as a positive scalar
        speeds = np.abs(speeds)

        directions_deg = mtools.recastasnpfloatarray(wind_dirs_deg)

        relative_heading_rad = np.deg2rad(directions_deg - self.le_heading_degt)

        runway_component = speeds * np.cos(relative_heading_rad) # Headwind: +
        crosswind_component = speeds * np.sin(relative_heading_rad) # Right: +

        # Scalar output to a scalar input
        if isinstance(wind_dirs_deg, Number):
            return runway_component[0], crosswind_component[0]

        return runway_component, crosswind_component</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ADRpy.atmospheres.Runway.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, icao_code=None, rwyno=0, elevation_ft=0, heading=0, surf=&#39;ASP&#39;, length_ft=10000, width_ft=100)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, icao_code=None, rwyno=0,
             elevation_ft=0, heading=0, surf=&#39;ASP&#39;,
             length_ft=10000, width_ft=100):
    if icao_code:
        # Read relevant runway data from the ourairports.com database
        # le_... / he_... - numbers referring to the low/high end respectively
        rwy_file = os.path.join(os.path.dirname(__file__), &#34;data&#34;, &#34;runways.csv&#34;)
        with open(rwy_file, newline=&#39;&#39;) as rwyfile:
            runwaydata = csv.reader(rwyfile, delimiter=&#39;,&#39;)
            runwaylist = []
            for row in runwaydata:
                runwaylist.append(row)
        rindlst = [i for i, rwy in enumerate(runwaylist) if rwy[2] == icao_code]
        rind = rindlst[0]
        self.ident = runwaylist[rind + rwyno][0]
        self.airport_ref = runwaylist[rind + rwyno][1]
        self.airport_ident = runwaylist[rind + rwyno][2]
        self.length_ft = float(runwaylist[rind + rwyno][3])
        self.width_ft = float(runwaylist[rind + rwyno][4])
        self.surface = runwaylist[rind + rwyno][5]
        self.lighted = runwaylist[rind + rwyno][6]
        self.closed = runwaylist[rind + rwyno][7]
        self.le_ident = runwaylist[rind + rwyno][8]
        self.le_latitude_deg = runwaylist[rind + rwyno][9]
        self.le_longitude_deg = runwaylist[rind + rwyno][10]
        self.le_elevation_ft = float(runwaylist[rind + rwyno][11])
        self.le_heading_degt = float(runwaylist[rind + rwyno][12])
        try:
            self.le_displaced_threshold_ft = float(runwaylist[rind + rwyno][13])
        except ValueError:
            self.le_displaced_threshold_ft = float(&#39;nan&#39;)
        self.he_ident = runwaylist[rind + rwyno][14]
        self.he_latitude_deg = runwaylist[rind + rwyno][15]
        self.he_longitude_deg = runwaylist[rind + rwyno][16]
        self.he_elevation_ft = float(runwaylist[rind + rwyno][17])
        self.he_heading_degt = float(runwaylist[rind + rwyno][18])
        try:
            self.he_displaced_threshold_ft = float(runwaylist[rind + rwyno][19])
        except ValueError:
            self.he_displaced_threshold_ft = float(&#39;nan&#39;)
    else:
        # Define a custom runway based on the data provided
        self.ident = &#39;0000000&#39;
        self.airport_ref = &#39;0000&#39;
        self.airport_ident = &#39;CUST&#39;
        self.length_ft = length_ft
        self.width_ft = width_ft
        self.surface = surf
        self.lighted = 1
        self.closed = 0
        self.le_ident = str(int(heading/10))
        self.le_latitude_deg = 0
        self.le_longitude_deg = 0
        self.le_elevation_ft = elevation_ft
        self.le_heading_degt = str(heading)
        self.le_displaced_threshold_ft = 0
        self.he_ident = str(int(reciprocalhdg(heading)/10))
        self.he_latitude_deg = 0
        self.he_longitude_deg = 0
        self.he_elevation_ft = elevation_ft
        self.he_heading_degt = str(reciprocalhdg(heading))
        self.he_displaced_threshold_ft = 0

    # Metric versions of the imperial fields listed above
    self.length_m = co.feet2m(self.length_ft)
    self.width_m = co.feet2m(self.width_ft)
    self.le_elevation_m = co.feet2m(self.le_elevation_ft)
    self.le_displaced_threshold_m = co.feet2m(self.le_displaced_threshold_ft)
    self.he_elevation_m = co.feet2m(self.he_elevation_ft)
    self.he_displaced_threshold_m = co.feet2m(self.he_displaced_threshold_ft)</code></pre>
</details>
</dd>
<dt id="ADRpy.atmospheres.Runway.windcomponents"><code class="name flex">
<span>def <span class="ident">windcomponents</span></span>(<span>self, wind_dirs_deg, wind_speeds)</span>
</code></dt>
<dd>
<section class="desc"><p>Resolves list of wind speeds and directions into runway/cross components</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def windcomponents(self, wind_dirs_deg, wind_speeds):
    &#34;&#34;&#34;Resolves list of wind speeds and directions into runway/cross components&#34;&#34;&#34;

    speeds = mtools.recastasnpfloatarray(wind_speeds)

    # Wind speed is considered as a positive scalar
    speeds = np.abs(speeds)

    directions_deg = mtools.recastasnpfloatarray(wind_dirs_deg)

    relative_heading_rad = np.deg2rad(directions_deg - self.le_heading_degt)

    runway_component = speeds * np.cos(relative_heading_rad) # Headwind: +
    crosswind_component = speeds * np.sin(relative_heading_rad) # Right: +

    # Scalar output to a scalar input
    if isinstance(wind_dirs_deg, Number):
        return runway_component[0], crosswind_component[0]

    return runway_component, crosswind_component</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ADRpy.atmospheres.geom2geop45m" href="#ADRpy.atmospheres.geom2geop45m">geom2geop45m</a></code></li>
<li><code><a title="ADRpy.atmospheres.geop2geom45m" href="#ADRpy.atmospheres.geop2geom45m">geop2geom45m</a></code></li>
<li><code><a title="ADRpy.atmospheres.idealgasdens_kgm3" href="#ADRpy.atmospheres.idealgasdens_kgm3">idealgasdens_kgm3</a></code></li>
<li><code><a title="ADRpy.atmospheres.idealgaspress_pa" href="#ADRpy.atmospheres.idealgaspress_pa">idealgaspress_pa</a></code></li>
<li><code><a title="ADRpy.atmospheres.mil_hdbk_310" href="#ADRpy.atmospheres.mil_hdbk_310">mil_hdbk_310</a></code></li>
<li><code><a title="ADRpy.atmospheres.pistonpowerfactor" href="#ADRpy.atmospheres.pistonpowerfactor">pistonpowerfactor</a></code></li>
<li><code><a title="ADRpy.atmospheres.pressratio" href="#ADRpy.atmospheres.pressratio">pressratio</a></code></li>
<li><code><a title="ADRpy.atmospheres.reciprocalhdg" href="#ADRpy.atmospheres.reciprocalhdg">reciprocalhdg</a></code></li>
<li><code><a title="ADRpy.atmospheres.tatbysat" href="#ADRpy.atmospheres.tatbysat">tatbysat</a></code></li>
<li><code><a title="ADRpy.atmospheres.tempratio" href="#ADRpy.atmospheres.tempratio">tempratio</a></code></li>
<li><code><a title="ADRpy.atmospheres.turbofanthrustfactor" href="#ADRpy.atmospheres.turbofanthrustfactor">turbofanthrustfactor</a></code></li>
<li><code><a title="ADRpy.atmospheres.turbojetthrustfactor" href="#ADRpy.atmospheres.turbojetthrustfactor">turbojetthrustfactor</a></code></li>
<li><code><a title="ADRpy.atmospheres.turbopropthrustfactor" href="#ADRpy.atmospheres.turbopropthrustfactor">turbopropthrustfactor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ADRpy.atmospheres.Atmosphere" href="#ADRpy.atmospheres.Atmosphere">Atmosphere</a></code></h4>
<ul class="two-column">
<li><code><a title="ADRpy.atmospheres.Atmosphere.__init__" href="#ADRpy.atmospheres.Atmosphere.__init__">__init__</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.airdens_kgpm3" href="#ADRpy.atmospheres.Atmosphere.airdens_kgpm3">airdens_kgpm3</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.airpress_mbar" href="#ADRpy.atmospheres.Atmosphere.airpress_mbar">airpress_mbar</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.airpress_pa" href="#ADRpy.atmospheres.Atmosphere.airpress_pa">airpress_pa</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.airtemp_c" href="#ADRpy.atmospheres.Atmosphere.airtemp_c">airtemp_c</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.airtemp_k" href="#ADRpy.atmospheres.Atmosphere.airtemp_k">airtemp_k</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.dynamicpressure_pa" href="#ADRpy.atmospheres.Atmosphere.dynamicpressure_pa">dynamicpressure_pa</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.eas2tas" href="#ADRpy.atmospheres.Atmosphere.eas2tas">eas2tas</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.keas2kcas" href="#ADRpy.atmospheres.Atmosphere.keas2kcas">keas2kcas</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.mach" href="#ADRpy.atmospheres.Atmosphere.mach">mach</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.mpseas2mpscas" href="#ADRpy.atmospheres.Atmosphere.mpseas2mpscas">mpseas2mpscas</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.tas2eas" href="#ADRpy.atmospheres.Atmosphere.tas2eas">tas2eas</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.vsound_kts" href="#ADRpy.atmospheres.Atmosphere.vsound_kts">vsound_kts</a></code></li>
<li><code><a title="ADRpy.atmospheres.Atmosphere.vsound_mps" href="#ADRpy.atmospheres.Atmosphere.vsound_mps">vsound_mps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ADRpy.atmospheres.Obsprofile" href="#ADRpy.atmospheres.Obsprofile">Obsprofile</a></code></h4>
<ul class="">
<li><code><a title="ADRpy.atmospheres.Obsprofile.__init__" href="#ADRpy.atmospheres.Obsprofile.__init__">__init__</a></code></li>
<li><code><a title="ADRpy.atmospheres.Obsprofile.hialt" href="#ADRpy.atmospheres.Obsprofile.hialt">hialt</a></code></li>
<li><code><a title="ADRpy.atmospheres.Obsprofile.loalt" href="#ADRpy.atmospheres.Obsprofile.loalt">loalt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ADRpy.atmospheres.Runway" href="#ADRpy.atmospheres.Runway">Runway</a></code></h4>
<ul class="">
<li><code><a title="ADRpy.atmospheres.Runway.__init__" href="#ADRpy.atmospheres.Runway.__init__">__init__</a></code></li>
<li><code><a title="ADRpy.atmospheres.Runway.windcomponents" href="#ADRpy.atmospheres.Runway.windcomponents">windcomponents</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>